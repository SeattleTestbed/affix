#!python
"""
<Program Name>
  affix_stack.repy

<Author>
  Monzur Muhammad, monzum@cs.washington.edu

<Date Started>
  March 2011

<Purpose>
  This module creates and maintains a stack of affixs which
  can be used to alter network calls in various ways.

  The user creates a affix stack object by providing a string
  which contains the list of affixs in order that they should be
  used with all their arguments.

  The stack holds the affixs in order and each of the affixs in the
  stack also has a reference to where it is in the stack. This way
  each of the affix is able to know all the affixs that are below it
  in the stack. An example affix stack will look like:

              Affix Stack
          -----------------
          |  ===========  |
          |  =  AffixA  =  |
          |  ===========  |
          |       |       |
          |       V       |
          |  ===========  |
          |  =  AffixB  =  |
          |  ===========  |
          |       |       |
          |       V       |
          |  ===========  |
          |  =  AffixC  =  |
          |  ===========  |
          -----------------
                  |
                  V
       -----------------------
       Original Repy API calls
       -----------------------


  In this case AffixA is able to see both AffixB and AffixC. AffixB is 
  able to see only AffixC, and AffixC is not able to see any of the affix. 

  When writing a new affix, it must inherit from BaseAffix (baseaffix.repy)
  and the file name must be all lowercase with no space or symbole in 
  file name. For example AffixA must have a filename affixa.repy This 
  particular naming convention is used so that AffixStack can dynamically 
  import all the affix files that are necessary without the user explicitly
  importing the affix files.

<History>
  03-07-2011: Renewed implementation of AffixStack.repy
"""


# Import the affix exceptions.
dy_import_module_symbols("affix_exceptions")

# A dictionary that holds all the affix objects that have been
# registered. This dictionary is shared globally by all AffixStacks
# because we need to register each affix only once.
AFFIX_CLASS_DICT = {}


# We have this function outside so each affix gets registed only once
# globaly. Otherwise we might run into some import error.
def find_and_register_affix(affix_name):
  """
  <Purpose>
    Given a affix, this function imports the affix file
    if it exists and then registers the affix class.
    Note that the expected naming convention of the affix
    files is that it will be all lower-case with no space
    or symbols in the name. 

    Example:
        If we have a affix called ExampleAffix then the file
        name is expected to be exampleaffix.repy

        ExampleAffix.repy, example_affix.repy or any other 
        forms are unaccepted.

  <Arguments>
    affix_name - The name of the affix that must be imported 
        and registered.

  <Side Effects>
    Repy library file is imported.

  <Exceptions>
    AffixNotFoundError - raised if the requested affix_name does
        not exist or is not in the current directory.

    AssertionError - raised if arguments provided is of an 
        unexpected type or value.
  <Return>
    None
  """

  assert(isinstance(affix_name, str)), "Bad arg type. affix_name must be a string."

  # If the affix class has already been registered, then we don't
  # need to do anything.
  if affix_name in AFFIX_CLASS_DICT.keys():
    return

  # We have to do the import in a while loop in case we get the 
  # FileInUseError. This error occurs when multiple affix stacks
  # may be trying to load the affix.
  while True:
    # Try to import the affix file. We convert the name to 
    # lower case before importing.
    try:
      if affix_name not in _context.keys():
        dy_import_module_symbols(affix_name.lower())
    except FileInUseError, err:
      sleep(0.01)
    else:
      break

  # Register the affix.
  AFFIX_CLASS_DICT[affix_name] = _context.copy()[affix_name]    
          



# Register the base affix class before doing anything.
# The base affix is used by all other affixs.
find_and_register_affix('BaseAffix')    





# ======================================================================================================
# AffixStack Class - The main AffixStack class that is used.
# ======================================================================================================



class AffixStack:


  def __init__(self, affix_stack_str='', localhost=None):
    """
    <Purpose>
      Initialize the stack of affixs. Parse the affix stack string
      and create the stack from it.
  
    <Arguments>
      affix_stack_str - A string that contains all the affixs that
          are going to be used, and the order that they will be
          used in.

      localhost - Its the ip/hostname that this machine will be 
          known by. It should be a string.

    <Side Effects>
      None

    <Exceptions>
      AffixArgumentError - raised if the arguments provided is not
          the expected value or type.

      AffixConfigError - raised if unable to parse affix string.

    <Return>
      None
    """

    # This is the context that will keep track of the state of this
    # affix stack. 
    self.affix_stack_context = {}
    self.affix_stack_context['localhost'] = 'localhost'
    self.affix_stack_context['top_affix'] = None
    self.affix_stack_context['affix_str'] = '' 
    self.affix_stack_context['affix_class'] = {}
  

    
    # Ensure that if the localhost was provided then it is in
    # the string form. Note that we don't check the data type 
    # for affix_stack_str as it is checked in the function
    # make_affix_stack()
    if localhost and not isinstance(localhost, str):
      raise AffixArgumentError("The 'localhost' provided must be a string.")

    self.make_affix_stack(affix_stack_str, self.affix_stack_context['top_affix'])

    self.affix_stack_context['localhost'] = localhost
    self.affix_stack_context['affix_str'] = affix_stack_str





# ==================================================================================
# Public Methods - Used by developers to manipulate affix stack.
# ==================================================================================

  def push(self, affix_object):
    """
    <Purpose>
      Add the affix_object to the top of the stack.

    <Arguments>
      affix_object - the affix that needs to be added to the stack.

    <Side Effects>
      The stack of the current top affix gets modified

    <Exceptions>
      AffixStackError - raised if unable to add affix_object to stack.
    
    <Return>
      None
    """
    
    # Monzur: The affix objects are of different class types. They all inherit from
    # BaseAffix but is there a way to check if its a proper affix object?

    # Get the top affix of this stack.
    cur_top_affix = self.affix_stack_context['top_affix']

    # If this is the first layer of affix and nothing has been 
    # added to the stack yet.
    if cur_top_affix: 
      # If the current stack is not empty, we push the top affix to
      # the new affix objects stack, and then make the new affix object
      # the new top affix.
      affix_object.affix_context['affix_stack'].push(cur_top_affix)

    self.affix_stack_context['top_affix'] = affix_object


      



  def pop(self):
    """
    <Purpose>
      Remove and return the very top affix layer from the affix stack.
      If stack is empty, it raises an error

    <Arguments>
      None

    <Side Effects>
      Stack gets modified.

    <Exception>
      AffixStackError - raised if the affix stack is empty.

    <Return>
      The top layer affix object.
    """

    # This function is equivalent to:
    #     old_root = root
    #     root = old_root.next
    #     return old_root
   
    top_affix = self.affix_stack_context['top_affix']
    
    if not top_affix:
      raise AffixStackError("Affix stack is empty. Cannot pop() from stack.")

    # Equivalent to top_affix = top_affix.next_affix()
    self.affix_stack_context['top_affix'] = top_affix.affix_context['affix_stack'].affix_stack_context['top_affix']

    # Monzur - Before we return the top_affix, should we point top_affixs affix stack to None?
    # User may be able to modify the current affix stack because the top_affix that is returned
    # has reference to the rest of the stack. Or perhaps we should return a copy() of the top 
    # affix?

    return top_affix





  def peek(self):
    """
    <Purpose>
      Return a copy of the top affix.

    <Arguments>
      None

    <Side Effects>
      None

    <Exception>
      AffixStackError - raised if affix stack is empty.

    <Return>
      A copy of the top affix.
    """

    if not self.affix_stack_context['top_affix']:
      raise AffixStackError("Affix stack is empty. Cannot peek() from stack.")

    # Note that this copy method is the copy() method that exists in 
    # each individual affix and is not the copy method of the affix stack.

    # Monzur - Should we return a copy here or should we return the original
    # affix object? Right now I am returning a copy so peek() cannot be used
    # to modify anything below this affix.    
    copy_top_affix = self.affix_stack_context['top_affix'].copy()

    return copy_top_affix

    # Monzur - I decided to send the reference to the actual affix stack
    # as it seems reasonable that peek should be able to be used to modify
    # the affix stack below it.
    #return self.affix_stack_context['top_affix']





  def copy(self):
    """
    <Purpose>
      Does a hard copy of self and returns it.

    <Arguments>
      None

    <Side Effects>
      None

    <Exception>
      None

    <Return>
      A AffixStack object. Its a copy of self.
    """

    new_stack = AffixStack('', self.affix_stack_context['localhost'])

    # If affix stack is not empty then we want to copy over
    # the top affix to the new AffixStack we just created.

    if self.affix_stack_context['top_affix']:
      # Copy over the top affix. Note that peek() is supposed
      # to return a copy of the object and not a reference
      # to it.
      new_stack.push(self.peek())

    return new_stack

  def gethostname(self): 
    return self.affix_stack_context['localhost']


# =========================== End of Public Methods ================================



  def make_affix_stack(self, affix_str, stack_object):
    """
    <Purpose>
      Recursively build up a affix stack from a affix string.

    <Arguments>
      affix_str - a affix string used to build affix stack.
      stack_object - the current affix stack.

    <Side Effects>
      None

    <Exceptions>
      AffixNotFoundError - Raised if one of the affixs in the 
          affix_str is not a valid affix or the affix file could
          not be found.
 
      AffixConfigError - raised if affix string is not in the right
          format.

      AssersionError - may be raised if one of the arguments provided
          is an unexpected type or value.

    <Return>
      A affix stack list or none if affix_str is empty.
    """


    # Some sanity checks.
    assert(isinstance(affix_str, str)), "Bad arg type. affix_str must be a string."
    
    # We are going to work our way up from the bottom. So we 
    # recursively go to the bottom of the stack and then
    # start constructiong the affixs and then add them to the
    # stack. That way the first item in the affix_str will be
    # at the top of the stack. 

    # Base case.
    if not affix_str:
      self.affix_stack_context['top_affix'] = None
      return

    # Build stack recursively. Any exceptions raised will just
    # percolate up. This may raise a AffixConfigError
    top_affix_name, affix_args, leftover_affix_str = self.parse_affix_string(affix_str)


    # Ensure the first argument is a legit string. If it is, we are going to load
    # the affix file if we find it. We assert and register the affix before building
    # the rest of the stack in order to fail early if we are unable to register
    # the top affix.
    assert(isinstance(top_affix_name, str)), "Bad arg type. First arg in affix tuple must be string."
    find_and_register_affix(top_affix_name)

    # Create a affix stack for the rest of the affixs below us, 
    # make that our current affix stack. After we create the affix 
    # stack with the leftover affix_str we are going to copy over
    # the new AffixStack objects stack_object to our own stack_object.
    # After we have copied it, we can now push on the top affix on top
    # of it.
    new_stack_object = AffixStack(leftover_affix_str, self.affix_stack_context['localhost']

    # Create the new affix object.
    # The new stack will have a copy of the affixstack before this 
    # layer is added. So if this is the first layer, then the 
    # Underlying stack beneath it would be None.
    top_affix = self.create_affix_object(top_affix_name, affix_args, new_stack_object)


    # Link the top affix to the affix stack object. This makes top_affix
    # the root/head of the affix stack. Even though it is called a affix
    # stack, the internals of the stack will work like a linked list.
    self.push(top_affix)

    # Return the top affix. Do we need to return anything? I am returning for convenience.
    # If this is the first layer then our peek may be empty.
    try:
      return_layer = self.peek()
    except AffixStackError:
      return_layer = None
    return return_layer
    



  

  def create_affix_object(self, affix_name, affix_args, affix_stack_object):
    """
    <Purpose>
      Create a affix object given a affix name and its arguments.

    <Arguments>
      affix_name - a string that defines the name of the affix.

      affix_args - the arguments to use to create the affix.

      affix_stack_object - the affix stack that will be below the new affix
          object that we are creating.

    <Side Effects>
      None

    <Exceptions>
      AffixNotFoundError - raised if the affix has not been 
          registered yet.

      AssertionError - raised if the arguments provided is 
          of an unexpected type or value. 

    <Return>
      A affix object.    
    """

    # Sanity check.
    assert(isinstance(affix_name, str)), "Bad arg type. affix_name must be a string."
    assert(isinstance(affix_args, list)), "Bad arg type. affix_args must be a list."
    #assert(isinstance(affix_stack_object, AffixStack)), "Bad arg type. affix_stack_object must be a AffixStack."

    if affix_name not in AFFIX_CLASS_DICT.keys():
      raise AffixNotFoundError("Affix '%s' has not been registered yet." % affix_name)

    # Create a new affix object from the name and arguments provided.
    affix_object_class = AFFIX_CLASS_DICT[affix_name]

    new_affix_object = affix_object_class(affix_stack_object, affix_args)

    return new_affix_object


  


  def parse_affix_string(self, affix_str):
    """
    <Purpose>
      Makes sure that the affix string provided is in the
      right format. Basically ensure that the parentheses 
      all match up.

    <Arguments>
      affix_str - a string that has the list of affixs and their
          arguments. A affix should be of the format:
         
            (AffixName,arg1,arg2,...)

    <Side Effects>
      None

    <Exceptions>
      AffixConfigError - raised if unable to parse affix string properly.

    <Return>
      A tuple that contains the first affix name, its arguments
      and the rest of the affix string.
      Example:
          ("AffixA", [argA1, argA2, argA3], "(AffixB)(AffixC,argC1)") 
    """

    # Sanity check.
    assert(isinstance(affix_str, str)), "Bad arg type. affix_str must be string."
    assert(affix_str), "affix_str must not be empty"

    open_paren_count = 0
    cur_affix_config = ""
    
    while affix_str:
      # Extract the first character of affix string.
      chr = affix_str[0]
      affix_str = affix_str[1:]

      if chr == '(':
        # The case where one of the arguments for the affix includes
	# parentheses..
        if open_paren_count != 0:
	  cur_affix_config += chr
        open_paren_count += 1
        

      elif chr == ')':
        open_paren_count -= 1

	# If there is a closed parentheses as part of the argument.
	if open_paren_count > 0:
	  cur_affix_config += chr

        # If we have uncovered a full affix config.
        elif open_paren_count == 0:
	  break

        # For the case of an extra close parentheses.
        if open_paren_count < 0:
          raise AffixConfigError("Incorrect affix string format. " +
              "Mismatched parentheses.")

      else:
        # Make sure that we have an open parentheses.
        if open_paren_count > 0:
          cur_affix_config += chr

        # This is the case where there is a character outside the
        # parentheses. An example would be:
        # '(AffixA, arg_a)foo(AffixB)', where 'foo' is not in the
        # affix config.
        else:
	  err = "Incorrect affix string format."
	  err += " Affix string provided: " + affix_str
          raise AffixConfigError(err)


    # The case where we have finished parsing the affix string and 
    # There was a mismatch of parentheses.
    if open_paren_count > 0:
      raise AffixConfigError("Incorrect affix string format. " +
          "Mismatched parentheses.")


    # Split the name and the arguments.
    affix_name = ''
    affix_arg_list = []
    paren_count = 0
    
    # Get the name out.
    while cur_affix_config:
      chr = cur_affix_config[0]
      cur_affix_config = cur_affix_config[1:]
    
      if chr != ',':
        affix_name += chr
      else:
        break

    # Split the arguments. Cant use the split command.
    cur_argument = ''
    while cur_affix_config:
      chr = cur_affix_config[0]
      cur_affix_config = cur_affix_config[1:]

      if chr == '(':
        paren_count += 1
      elif chr == ')':
        paren_count -= 1
      elif chr == ',':
        # If we are outside a affix.
        if paren_count == 0:
          # We have uncovered an argument. Add it to the
	  # list and clear the current argument.
          affix_arg_list.append(cur_argument)     
          cur_argument = ''
          continue

      # Add the character to the current argument string.
      cur_argument += chr

    # If there was a leftover last argument.
    if cur_argument:
      affix_arg_list.append(cur_argument)
      

    # Return format is: (affix_name, affix_args_list, rest_of_affix_string)
    return (affix_name, affix_arg_list, affix_str)

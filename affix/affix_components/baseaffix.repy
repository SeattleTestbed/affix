"""
<Program Name>
  baseaffix.repy

<Author>
  Danny Y. Huang, yh1@cs.williams.edu
  Monzur Muhammad, monzum@cs.washington.edu

<Date Started>
  March 7th, 2011.
  Originally written by Danny on June 2010.

<Purpose>
  This is the core of a affix. The very base interface
  that every affix has to extend and implement specified
  functions. Note that this file itself is not a affix
  in itself but rather the skeleton of a affix.
"""

# Import all the exceptions.
dy_import_module_symbols("affix_exceptions")

# Import all the wrapper classes.
dy_import_module_symbols("affix_wrapper_lib")



class BaseAffix:


  def __init__(self, affix_stack, optional_args=None):
    """
    <Purpose>
      Initialize this particular affix.

    <Arguments>
      affix_stack - This is the affix stack that resides beneath
          the current affix. It can be used to view and modify
          the stack beneath it.

      optional_args - Any optional argument that this particular 
          affix takes.

    <Side Effects>
      None

    <Exceptions>
      None

    <Return>
      None
    """

    # Global variables that are used to keep the state of this affix.
    self.affix_context = {'optional_args' : None,
                         'affix_stack' : None
                        }


    # Ensure that the reference to the affixstack that we get
    # is of the type AffixStack.
    #try:
    #  assert(isinstance(affix_stack, AffixStack))
    #except:
    #  err = "Bad arg provided. affix_stack must be of type AffixStack."
    #  err += " Type provided: '%s'" % str(type(affix_stack))
    #  raise AffixArgumentError(err)

    self.affix_context['optional_args'] = optional_args
    
    # I am going to do a copy just to make sure we don't have any 
    # reference to it.
    self.affix_context['affix_stack'] = affix_stack



  
  # ===========================================================================
  # Public methods that the child classes must override.
  # ===========================================================================


  def copy(self):
    """
    Returns a copy of the current instance. Be sure to set internal states to be
    copied in the new object. An example would be:

    class MyAffix(BaseAffix):
      def copy(self):
		mycopy = MyAffix(self.affix_context['affix_stack'].copy(), self.affix_context['optional_args']
        mycopy._internalstate = self._internalstate
        return mycopy

    """
    raise AffixError("The copy() method is not implemented.")



  def get_advertisement_string(self):
    """
    Returns the string used for advertisement of this affix. For example:

    class MyAffix(BaseAffix):
      def get_advertisement_string(self):
        return '(MyAffix,' + str(self._some_shared_state) + ')' + self.get_next_affix_layer().get_advertisement_string()

    If the subclass affix is not meant to be public, then simply return an empty
    string.

    """
    raise AffixError("The get_advertisement_string() method is not implemented.")  




  # ===============================================================================
  # This is a public method that is used to retrieve the next layer of affix.
  # ===============================================================================
 
  def get_next_affix_layer(self):
    """
    <Purpose>
      Peek into the affix stack and return the next layer
      of affix. If the affix stack is empty, then we will 
      return the RepyNetworkApi object, which is used to
      call the original repy network calls.

    <Arguments>
      None

    <Side Effects>
      None

    <Exceptions>
      None.

    <Return>
      Next layer of affix or an object that encompasses the original
      repy network api.
    """
    
    try:
      next_layer = self.affix_context['affix_stack'].peek()
    except AffixStackError:
      # This is the case when the affix stack is empty.
      # So we return a wrapper object which will allow
      # us to use the original repy network api calls.
      next_layer = RepyNetworkApiWrapper()

    return next_layer



  def getaffixstack(self):
    return self.affix_context['affix_stack']
    
  def gethostname(self):
    return self.getaffixstack().gethostname()

  # ============================================================================
  # Public methods that directly interface with the application. The methods may
  # be overwritten by the affix objects that inherit the base affix. If the methods
  # are not overwritten, then these methods will be used in the affix that inherits
  # them.
  # ===========================================================================

  def sendmessage(self, destip, destport, message, localip, localport):
    return self.get_next_affix_layer().sendmessage(destip, destport, message, localip, localport)



  def listenformessage(self, localip, localport):
    next_layer_socket = self.get_next_affix_layer().listenformessage(localip, localport)
    return AffixUDPServerSocket(next_layer_socket, self)



  def openconnection(self, destip, destport, localip, localport, timeout):
    # We make a copy of ourselves before we do anything as we may have multiple
    # openconnection calls that return multiple real sockets.
    #this_affix_copy = self.copy()
    next_sockobj = self.get_next_affix_layer().openconnection(destip, destport, localip, localport, timeout)
    
    return AffixSocket(next_sockobj, self)



  def listenforconnection(self, localip, localport):
    # TODO: Not sure if we have to make a copy of self before retrieving
    # the next layer.
    next_layer_socket = self.get_next_affix_layer().listenforconnection(localip, localport)
    return AffixTCPServerSocket(next_layer_socket, self)



  def socket_close(self, socket):
    return self.get_next_affix_layer().socket_close(socket)



  def socket_send(self, socket, msg):
    return self.get_next_affix_layer().socket_send(socket, msg)



  def socket_recv(self, socket, bytes):
    return self.get_next_affix_layer().socket_recv(socket, bytes)



  def tcpserversocket_getconnection(self, tcpserversocket):
    # We make a copy of ourselves before doing a getconnection
    # as this function may be invoked multiple times and they 
    # may each modify the affix stack below it differently. 
    #this_affix_copy = self.copy()
    (remote_ip, remote_port, repy_socket) = self.get_next_affix_layer().tcpserversocket_getconnection(tcpserversocket)

    return (remote_ip, remote_port, AffixSocket(repy_socket, self))



  def tcpserversocket_close(self, tcpserversocket):
    return self.get_next_affix_layer().tcpserversocket_close(tcpserversocket)



  def udpserversocket_getmessage(self, udpserversocket):
    return self.copy().get_next_affix_layer().udpserversocket_getmessage(udpserversocket)



  def udpserversocket_close(self, udpserversocket):
    return self.get_next_affix_layer().udpserversocket_close(udpserversocket)


  def __str__(self):
    return '(%s)' % repr(self).replace(' instance at', '') + str(self.get_next_affix_layer())
